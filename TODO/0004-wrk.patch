From e68ca06a745052d79ef669c79fada090834a9aa0 Mon Sep 17 00:00:00 2001
From: mdxd44 <mdxd44@ely.su>
Date: Tue, 15 Jun 2021 09:57:14 +0900
Subject: [PATCH] wrk


diff --git a/HEADER_BUNGEECORD.txt b/HEADER_BUNGEECORD.txt
new file mode 100644
index 00000000..77a0f845
--- /dev/null
+++ b/HEADER_BUNGEECORD.txt
@@ -0,0 +1,30 @@
+This file is part of BungeeCord, licensed under the BSD License (BSD).
+
+Copyright (c) 2012 md_5
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimer in the documentation
+      and/or other materials provided with the distribution.
+    * The name of the author may not be used to endorse or promote products derived
+      from this software without specific prior written permission.
+    * You may not use the software for commercial software hosting services without
+      written permission from the author.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
index d1502f0d..6834863d 100644
--- a/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
+++ b/proxy/src/main/java/com/velocitypowered/proxy/VelocityServer.java
@@ -41,7 +41,6 @@ import com.velocitypowered.proxy.command.VelocityCommandManager;
 import com.velocitypowered.proxy.command.builtin.GlistCommand;
 import com.velocitypowered.proxy.command.builtin.ServerCommand;
 import com.velocitypowered.proxy.command.builtin.ShutdownCommand;
-import com.velocitypowered.proxy.command.builtin.VelocityCommand;
 import com.velocitypowered.proxy.config.VelocityConfiguration;
 import com.velocitypowered.proxy.connection.client.ConnectedPlayer;
 import com.velocitypowered.proxy.connection.player.VelocityResourcePackInfo;
@@ -99,6 +98,7 @@ import org.checkerframework.checker.nullness.qual.EnsuresNonNull;
 import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
+import ru.elytrium.elytraproxy.ElytraProxy;
 
 public class VelocityServer implements ProxyServer, ForwardingAudience {
 
@@ -138,6 +138,7 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
   private final VelocityEventManager eventManager;
   private final VelocityScheduler scheduler;
   private final VelocityChannelRegistrar channelRegistrar = new VelocityChannelRegistrar();
+  private ElytraProxy elytraProxy; // ElytraProxy
 
   VelocityServer(final ProxyOptions options) {
     pluginManager = new VelocityPluginManager(this);
@@ -201,7 +202,8 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     cm.logChannelInformation();
 
     // Initialize commands first
-    commandManager.register("velocity", new VelocityCommand(this));
+    // ElytraProxy: Move initialisation to ElytraProxy class
+    //commandManager.register("velocity", new VelocityCommand(this));
     commandManager.register("server", new ServerCommand(this));
     commandManager.register("shutdown", new ShutdownCommand(this),"end");
     new GlistCommand(this).register();
@@ -235,6 +237,9 @@ public class VelocityServer implements ProxyServer, ForwardingAudience {
     }
 
     Metrics.VelocityMetrics.startMetrics(this, configuration.getMetrics());
+
+    // ElytraProxy: Init ElytraProxy
+    this.elytraProxy = new ElytraProxy(this);
   }
 
   @SuppressFBWarnings("DM_EXIT")
diff --git a/proxy/src/main/java/com/velocitypowered/proxy/command/builtin/VelocityCommand.java b/proxy/src/main/java/com/velocitypowered/proxy/command/builtin/VelocityCommand.java
deleted file mode 100644
index 6eaf7d69..00000000
--- a/proxy/src/main/java/com/velocitypowered/proxy/command/builtin/VelocityCommand.java
+++ /dev/null
@@ -1,468 +0,0 @@
-/*
- * Copyright (C) 2018 Velocity Contributors
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.velocitypowered.proxy.command.builtin;
-
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.MoreExecutors;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
-import com.velocitypowered.api.command.CommandSource;
-import com.velocitypowered.api.command.SimpleCommand;
-import com.velocitypowered.api.permission.Tristate;
-import com.velocitypowered.api.plugin.PluginContainer;
-import com.velocitypowered.api.plugin.PluginDescription;
-import com.velocitypowered.api.proxy.ProxyServer;
-import com.velocitypowered.api.proxy.server.RegisteredServer;
-import com.velocitypowered.api.util.ProxyVersion;
-import com.velocitypowered.proxy.VelocityServer;
-import com.velocitypowered.proxy.util.InformationUtils;
-
-import java.net.ConnectException;
-import java.net.UnknownHostException;
-import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.concurrent.ExecutionException;
-import java.util.stream.Collectors;
-
-import net.kyori.adventure.identity.Identity;
-import net.kyori.adventure.text.Component;
-import net.kyori.adventure.text.TextComponent;
-import net.kyori.adventure.text.event.ClickEvent;
-import net.kyori.adventure.text.event.HoverEvent;
-import net.kyori.adventure.text.format.NamedTextColor;
-import net.kyori.adventure.text.format.TextColor;
-import net.kyori.adventure.text.format.TextDecoration;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-import org.asynchttpclient.AsyncHttpClient;
-import org.asynchttpclient.BoundRequestBuilder;
-import org.asynchttpclient.ListenableFuture;
-import org.asynchttpclient.Response;
-import org.checkerframework.checker.nullness.qual.NonNull;
-
-public class VelocityCommand implements SimpleCommand {
-
-  private interface SubCommand {
-
-    void execute(final CommandSource source, final String @NonNull [] args);
-
-    default List<String> suggest(final CommandSource source, final String @NonNull [] currentArgs) {
-      return ImmutableList.of();
-    }
-
-    boolean hasPermission(final CommandSource source, final String @NonNull [] args);
-  }
-
-  private final Map<String, SubCommand> commands;
-
-  /**
-   * Initializes the command object for /velocity.
-   *
-   * @param server the Velocity server
-   */
-  public VelocityCommand(VelocityServer server) {
-    this.commands = ImmutableMap.<String, SubCommand>builder()
-        .put("version", new Info(server))
-        .put("plugins", new Plugins(server))
-        .put("reload", new Reload(server))
-        .put("dump", new Dump(server))
-        .build();
-  }
-
-  private void usage(CommandSource source) {
-    String availableCommands = commands.entrySet().stream()
-        .filter(e -> e.getValue().hasPermission(source, new String[0]))
-        .map(Map.Entry::getKey)
-        .collect(Collectors.joining("|"));
-    String commandText = "/velocity <" + availableCommands + ">";
-    source.sendMessage(Identity.nil(), Component.text(commandText, NamedTextColor.RED));
-  }
-
-  @Override
-  public void execute(final SimpleCommand.Invocation invocation) {
-    final CommandSource source = invocation.source();
-    final String[] args = invocation.arguments();
-
-    if (args.length == 0) {
-      usage(source);
-      return;
-    }
-
-    SubCommand command = commands.get(args[0].toLowerCase(Locale.US));
-    if (command == null) {
-      usage(source);
-      return;
-    }
-    @SuppressWarnings("nullness")
-    String[] actualArgs = Arrays.copyOfRange(args, 1, args.length);
-    command.execute(source, actualArgs);
-  }
-
-  @Override
-  public List<String> suggest(final SimpleCommand.Invocation invocation) {
-    final CommandSource source = invocation.source();
-    final String[] currentArgs = invocation.arguments();
-
-    if (currentArgs.length == 0) {
-      return commands.entrySet().stream()
-              .filter(e -> e.getValue().hasPermission(source, new String[0]))
-              .map(Map.Entry::getKey)
-              .collect(ImmutableList.toImmutableList());
-    }
-
-    if (currentArgs.length == 1) {
-      return commands.entrySet().stream()
-          .filter(e -> e.getKey().regionMatches(true, 0, currentArgs[0], 0,
-              currentArgs[0].length()))
-          .filter(e -> e.getValue().hasPermission(source, new String[0]))
-          .map(Map.Entry::getKey)
-          .collect(ImmutableList.toImmutableList());
-    }
-
-    SubCommand command = commands.get(currentArgs[0].toLowerCase(Locale.US));
-    if (command == null) {
-      return ImmutableList.of();
-    }
-    @SuppressWarnings("nullness")
-    String[] actualArgs = Arrays.copyOfRange(currentArgs, 1, currentArgs.length);
-    return command.suggest(source, actualArgs);
-  }
-
-  @Override
-  public boolean hasPermission(final SimpleCommand.Invocation invocation) {
-    final CommandSource source = invocation.source();
-    final String[] args = invocation.arguments();
-
-    if (args.length == 0) {
-      return commands.values().stream().anyMatch(e -> e.hasPermission(source, args));
-    }
-    SubCommand command = commands.get(args[0].toLowerCase(Locale.US));
-    if (command == null) {
-      return true;
-    }
-    @SuppressWarnings("nullness")
-    String[] actualArgs = Arrays.copyOfRange(args, 1, args.length);
-    return command.hasPermission(source, actualArgs);
-  }
-
-  private static class Reload implements SubCommand {
-
-    private static final Logger logger = LogManager.getLogger(Reload.class);
-    private final VelocityServer server;
-
-    private Reload(VelocityServer server) {
-      this.server = server;
-    }
-
-    @Override
-    public void execute(CommandSource source, String @NonNull [] args) {
-      try {
-        if (server.reloadConfiguration()) {
-          source.sendMessage(Identity.nil(), Component.text(
-              "Configuration reloaded.", NamedTextColor.GREEN));
-        } else {
-          source.sendMessage(Identity.nil(), Component.text(
-              "Unable to reload your configuration. Check the console for more details.",
-              NamedTextColor.RED));
-        }
-      } catch (Exception e) {
-        logger.error("Unable to reload configuration", e);
-        source.sendMessage(Identity.nil(), Component.text(
-            "Unable to reload your configuration. Check the console for more details.",
-            NamedTextColor.RED));
-      }
-    }
-
-    @Override
-    public boolean hasPermission(final CommandSource source, final String @NonNull [] args) {
-      return source.getPermissionValue("velocity.command.reload") == Tristate.TRUE;
-    }
-  }
-
-  private static class Info implements SubCommand {
-
-    private static final TextColor VELOCITY_COLOR = TextColor.fromHexString("#09add3");
-    private final ProxyServer server;
-
-    private Info(ProxyServer server) {
-      this.server = server;
-    }
-
-    @Override
-    public void execute(CommandSource source, String @NonNull [] args) {
-      if (args.length != 0) {
-        source.sendMessage(Identity.nil(), Component.text("/velocity version", NamedTextColor.RED));
-        return;
-      }
-
-      ProxyVersion version = server.getVersion();
-
-      TextComponent velocity = Component.text().content(version.getName() + " ")
-          .decoration(TextDecoration.BOLD, true)
-          .color(VELOCITY_COLOR)
-          .append(Component.text(version.getVersion()).decoration(TextDecoration.BOLD, false))
-          .build();
-      TextComponent copyright = Component
-          .text("Copyright 2018-2021 " + version.getVendor() + ". " + version.getName()
-              + " is licensed under the terms of the GNU General Public License v3.");
-      source.sendMessage(Identity.nil(), velocity);
-      source.sendMessage(Identity.nil(), copyright);
-
-      if (version.getName().equals("Velocity")) {
-        TextComponent velocityWebsite = Component.text()
-            .content("Visit the ")
-            .append(Component.text().content("Velocity website")
-                .color(NamedTextColor.GREEN)
-                .clickEvent(
-                    ClickEvent.openUrl("https://www.velocitypowered.com"))
-                .build())
-            .append(Component.text(" or the "))
-            .append(Component.text().content("Velocity GitHub")
-                .color(NamedTextColor.GREEN)
-                .clickEvent(ClickEvent.openUrl(
-                    "https://github.com/VelocityPowered/Velocity"))
-                .build())
-            .build();
-        source.sendMessage(Identity.nil(), velocityWebsite);
-      }
-    }
-
-    @Override
-    public boolean hasPermission(final CommandSource source, final String @NonNull [] args) {
-      return source.getPermissionValue("velocity.command.info") != Tristate.FALSE;
-    }
-  }
-
-  private static class Plugins implements SubCommand {
-
-    private final ProxyServer server;
-
-    private Plugins(ProxyServer server) {
-      this.server = server;
-    }
-
-    @Override
-    public void execute(CommandSource source, String @NonNull [] args) {
-      if (args.length != 0) {
-        source.sendMessage(Identity.nil(), Component.text("/velocity plugins", NamedTextColor.RED));
-        return;
-      }
-
-      List<PluginContainer> plugins = ImmutableList.copyOf(server.getPluginManager().getPlugins());
-      int pluginCount = plugins.size();
-
-      if (pluginCount == 0) {
-        source.sendMessage(Identity.nil(), Component.text(
-            "No plugins installed.", NamedTextColor.YELLOW));
-        return;
-      }
-
-      TextComponent.Builder output = Component.text().content("Plugins: ")
-          .color(NamedTextColor.YELLOW);
-      for (int i = 0; i < pluginCount; i++) {
-        PluginContainer plugin = plugins.get(i);
-        output.append(componentForPlugin(plugin.getDescription()));
-        if (i + 1 < pluginCount) {
-          output.append(Component.text(", "));
-        }
-      }
-
-      source.sendMessage(Identity.nil(), output.build());
-    }
-
-    private TextComponent componentForPlugin(PluginDescription description) {
-      String pluginInfo = description.getName().orElse(description.getId())
-          + description.getVersion().map(v -> " " + v).orElse("");
-
-      TextComponent.Builder hoverText = Component.text().content(pluginInfo);
-
-      description.getUrl().ifPresent(url -> {
-        hoverText.append(Component.newline());
-        hoverText.append(Component.text("Website: " + url));
-      });
-      if (!description.getAuthors().isEmpty()) {
-        hoverText.append(Component.newline());
-        if (description.getAuthors().size() == 1) {
-          hoverText.append(Component.text("Author: " + description.getAuthors().get(0)));
-        } else {
-          hoverText.append(Component.text("Authors: " + Joiner.on(", ")
-              .join(description.getAuthors())));
-        }
-      }
-      description.getDescription().ifPresent(pdesc -> {
-        hoverText.append(Component.newline());
-        hoverText.append(Component.newline());
-        hoverText.append(Component.text(pdesc));
-      });
-
-      return Component.text(description.getId(), NamedTextColor.GRAY)
-          .hoverEvent(HoverEvent.showText(hoverText.build()));
-    }
-
-    @Override
-    public boolean hasPermission(final CommandSource source, final String @NonNull [] args) {
-      return source.getPermissionValue("velocity.command.plugins") == Tristate.TRUE;
-    }
-  }
-
-  private static class Dump implements SubCommand {
-
-    private static final Logger logger = LogManager.getLogger(Dump.class);
-    private final ProxyServer server;
-
-    private Dump(ProxyServer server) {
-      this.server = server;
-    }
-
-    @Override
-    public void execute(CommandSource source, String @NonNull [] args) {
-      if (args.length != 0) {
-        source.sendMessage(Identity.nil(), Component.text("/velocity dump", NamedTextColor.RED));
-        return;
-      }
-
-      Collection<RegisteredServer> allServers = ImmutableSet.copyOf(server.getAllServers());
-      JsonObject servers = new JsonObject();
-      for (RegisteredServer iter : allServers) {
-        servers.add(iter.getServerInfo().getName(),
-                InformationUtils.collectServerInfo(iter));
-      }
-      JsonArray connectOrder = new JsonArray();
-      List<String> attemptedConnectionOrder = ImmutableList.copyOf(
-              server.getConfiguration().getAttemptConnectionOrder());
-      for (int i = 0; i < attemptedConnectionOrder.size(); i++) {
-        connectOrder.add(attemptedConnectionOrder.get(i));
-      }
-
-      JsonObject proxyConfig = InformationUtils.collectProxyConfig(server.getConfiguration());
-      proxyConfig.add("servers", servers);
-      proxyConfig.add("connectOrder", connectOrder);
-      proxyConfig.add("forcedHosts",
-              InformationUtils.collectForcedHosts(server.getConfiguration()));
-
-      JsonObject dump = new JsonObject();
-      dump.add("versionInfo", InformationUtils.collectProxyInfo(server.getVersion()));
-      dump.add("platform", InformationUtils.collectEnvironmentInfo());
-      dump.add("config", proxyConfig);
-      dump.add("plugins", InformationUtils.collectPluginInfo(server));
-
-      source.sendMessage(Component.text().content("Uploading gathered information...").build());
-      AsyncHttpClient httpClient = ((VelocityServer) server).getAsyncHttpClient();
-
-      BoundRequestBuilder request =
-              httpClient.preparePost("https://dump.velocitypowered.com/documents");
-      request.setHeader("Content-Type", "text/plain");
-      request.addHeader("User-Agent", server.getVersion().getName() + "/"
-              + server.getVersion().getVersion());
-      request.setBody(
-              InformationUtils.toHumanReadableString(dump).getBytes(StandardCharsets.UTF_8));
-
-      ListenableFuture<Response> future = request.execute();
-      future.addListener(() -> {
-        try {
-          Response response = future.get();
-          if (response.getStatusCode() != 200) {
-            source.sendMessage(Component.text()
-                    .content("An error occurred while communicating with the Velocity servers. "
-                            + "The servers may be temporarily unavailable or there is an issue "
-                            + "with your network settings. You can find more information in the "
-                            + "log or console of your Velocity server.")
-                    .color(NamedTextColor.RED).build());
-            logger.error("Invalid status code while POST-ing Velocity dump: "
-                    + response.getStatusCode());
-            logger.error("Headers: \n--------------BEGIN HEADERS--------------\n"
-                    + response.getHeaders().toString()
-                    + "\n---------------END HEADERS---------------");
-            return;
-          }
-          JsonObject key = InformationUtils.parseString(
-                  response.getResponseBody(StandardCharsets.UTF_8));
-          if (!key.has("key")) {
-            throw new JsonSyntaxException("Missing Dump-Url-response");
-          }
-          String url = "https://dump.velocitypowered.com/"
-                  + key.get("key").getAsString() + ".json";
-          source.sendMessage(Component.text()
-                  .content("Created an anonymised report containing useful information about "
-                          + "this proxy. If a developer requested it, you may share the "
-                          + "following link with them:")
-                  .append(Component.newline())
-                  .append(Component.text(">> " + url)
-                          .color(NamedTextColor.GREEN)
-                          .clickEvent(ClickEvent.openUrl(url)))
-                 .append(Component.newline())
-                 .append(Component.text("Note: This link is only valid for a few days")
-                          .color(NamedTextColor.GRAY)
-                 ).build());
-        } catch (InterruptedException e) {
-          source.sendMessage(Component.text()
-                  .content("Could not complete the request, the command was interrupted."
-                          + "Please refer to the proxy-log or console for more information.")
-                  .color(NamedTextColor.RED).build());
-          logger.error("Failed to complete dump command, "
-                  + "the executor was interrupted: " + e.getMessage());
-          e.printStackTrace();
-        } catch (ExecutionException e) {
-          TextComponent.Builder message = Component.text()
-                  .content("An error occurred while attempting to upload the gathered "
-                          + "information to the Velocity servers.")
-                  .append(Component.newline())
-                  .color(NamedTextColor.RED);
-          if (e.getCause() instanceof UnknownHostException
-              || e.getCause() instanceof ConnectException) {
-            message.append(Component.text(
-                    "Likely cause: Invalid system DNS settings or no internet connection"));
-          }
-          source.sendMessage(message
-                  .append(Component.newline()
-                  .append(Component.text(
-                          "Error details can be found in the proxy log / console"))
-                  ).build());
-
-          logger.error("Failed to complete dump command, "
-                  + "the executor encountered an Exception: " + e.getCause().getMessage());
-          e.getCause().printStackTrace();
-        } catch (JsonParseException e) {
-          source.sendMessage(Component.text()
-                  .content("An error occurred on the Velocity-servers and the dump could not "
-                          + "be completed. Please contact the Velocity staff about this problem. "
-                          + "If you do, provide the details about this error from the Velocity "
-                          + "console or server log.")
-                  .color(NamedTextColor.RED).build());
-          logger.error("Invalid response from the Velocity servers: " + e.getMessage());
-          e.printStackTrace();
-        }
-      }, MoreExecutors.directExecutor());
-    }
-
-    @Override
-    public boolean hasPermission(final CommandSource source, final String @NonNull [] args) {
-      return source.getPermissionValue("velocity.command.plugins") == Tristate.TRUE;
-    }
-  }
-}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java b/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java
new file mode 100644
index 00000000..0a6c582a
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/ElytraProxy.java
@@ -0,0 +1,4 @@
+package ru.elytrium.elytraproxy;
+
+public class ElytraProxy {
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java
new file mode 100644
index 00000000..00f02ca3
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/commands/ElytraProxyCommand.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2018 Velocity Contributors
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.commands;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.velocitypowered.api.command.CommandSource;
+import com.velocitypowered.api.command.SimpleCommand;
+import com.velocitypowered.proxy.VelocityServer;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import net.kyori.adventure.identity.Identity;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import ru.elytrium.elytraproxy.ElytraProxy;
+import ru.elytrium.elytraproxy.config.Settings;
+
+public class ElytraProxyCommand implements SimpleCommand {
+
+  private interface SubCommand {
+
+    void execute(final CommandSource source, final String @NonNull [] args);
+
+    default List<String> suggest(final CommandSource source, final String @NonNull [] currentArgs) {
+      return ImmutableList.of();
+    }
+
+    boolean hasPermission(final CommandSource source, final String @NonNull [] args);
+  }
+
+  private final Map<String, SubCommand> commands;
+
+  /**
+   * Initializes the command object for /velocity.
+   *
+   * @param server the Velocity server
+   */
+  public ElytraProxyCommand(VelocityServer server, ElytraProxy elytraProxy) {
+    this.commands = ImmutableMap.<String, SubCommand>builder()
+        .put("reload", new Reload(server, elytraProxy))
+        .build();
+  }
+
+  private void usage(CommandSource source) {
+    source.sendMessage(Identity.nil(), Component.text("§eThis server is using ElytraProxy"
+        + " that based on Velocity Proxy"));
+    source.sendMessage(Identity.nil(), Component.text("§eOriginal Velocity by astei"
+        + " and many-many contributors"));
+    source.sendMessage(Identity.nil(), Component.text("§eElytraProxy by Elytrium dev team"));
+    source.sendMessage(Identity.nil(), Component.text("§dMade With Love ❤"));
+    source.sendMessage(Identity.nil(), Component.text("§a"
+        + "https://github.com/Elytrium/ElytraProxy"));
+    if (source.hasPermission("elytraproxy.reload")) {
+      source.sendMessage(Identity.nil(), Component.text("§aCommands: "));
+      source.sendMessage(Identity.nil(), Component.text("§6/elytraproxy reload §7-§f"
+          + " reloads proxy server itself, without plugins"));
+    }
+  }
+
+  @Override
+  public void execute(final SimpleCommand.Invocation invocation) {
+    final CommandSource source = invocation.source();
+    final String[] args = invocation.arguments();
+
+    if (args.length == 0) {
+      usage(source);
+      return;
+    }
+
+    SubCommand command = commands.get(args[0].toLowerCase(Locale.US));
+    if (command == null) {
+      usage(source);
+      return;
+    }
+    @SuppressWarnings("nullness")
+    String[] actualArgs = Arrays.copyOfRange(args, 1, args.length);
+    command.execute(source, actualArgs);
+  }
+
+  @Override
+  public List<String> suggest(final SimpleCommand.Invocation invocation) {
+    final CommandSource source = invocation.source();
+    final String[] currentArgs = invocation.arguments();
+
+    if (currentArgs.length == 0) {
+      return commands.entrySet().stream()
+          .filter(e -> e.getValue().hasPermission(source, new String[0]))
+          .map(Map.Entry::getKey)
+          .collect(ImmutableList.toImmutableList());
+    }
+
+    if (currentArgs.length == 1) {
+      return commands.entrySet().stream()
+          .filter(e -> e.getKey().regionMatches(true, 0, currentArgs[0], 0,
+              currentArgs[0].length()))
+          .filter(e -> e.getValue().hasPermission(source, new String[0]))
+          .map(Map.Entry::getKey)
+          .collect(ImmutableList.toImmutableList());
+    }
+
+    SubCommand command = commands.get(currentArgs[0].toLowerCase(Locale.US));
+    if (command == null) {
+      return ImmutableList.of();
+    }
+    @SuppressWarnings("nullness")
+    String[] actualArgs = Arrays.copyOfRange(currentArgs, 1, currentArgs.length);
+    return command.suggest(source, actualArgs);
+  }
+
+  @Override
+  public boolean hasPermission(final SimpleCommand.Invocation invocation) {
+    final CommandSource source = invocation.source();
+    final String[] args = invocation.arguments();
+
+    if (args.length == 0) {
+      return commands.values().stream().anyMatch(e -> e.hasPermission(source, args));
+    }
+    SubCommand command = commands.get(args[0].toLowerCase(Locale.US));
+    if (command == null) {
+      return true;
+    }
+    @SuppressWarnings("nullness")
+    String[] actualArgs = Arrays.copyOfRange(args, 1, args.length);
+    return command.hasPermission(source, actualArgs);
+  }
+
+  private static class Reload implements SubCommand {
+
+    private static final Logger logger = LogManager.getLogger(Reload.class);
+    private final VelocityServer server;
+    private final ElytraProxy elytraProxy;
+
+    private Reload(VelocityServer server, ElytraProxy elytraProxy) {
+      this.server = server;
+      this.elytraProxy = elytraProxy;
+    }
+
+    @Override
+    public void execute(CommandSource source, String @NonNull [] args) {
+      try {
+        if (server.reloadConfiguration()) {
+          source.sendMessage(Identity.nil(),
+              LegacyComponentSerializer
+                  .legacyAmpersand()
+                  .deserialize((
+                      Settings.IMP.MESSAGES.ELYTRAPROXY.PREFIX
+                          + Settings.IMP.MESSAGES.VELOCITY.COMMAND.RELOAD_SUCCESS)
+                      .replace("%nl%", "\n")));
+        } else {
+          source.sendMessage(Identity.nil(),
+              LegacyComponentSerializer
+                  .legacyAmpersand()
+                  .deserialize((
+                      Settings.IMP.MESSAGES.ELYTRAPROXY.PREFIX
+                          + Settings.IMP.MESSAGES.VELOCITY.COMMAND.RELOAD_FAILURE)
+                      .replace("%nl%", "\n")));
+        }
+      } catch (Exception e) {
+        logger.error("Unable to reload configuration", e);
+        source.sendMessage(Identity.nil(),
+            LegacyComponentSerializer
+                .legacyAmpersand()
+                .deserialize((
+                    Settings.IMP.MESSAGES.ELYTRAPROXY.PREFIX
+                        + Settings.IMP.MESSAGES.VELOCITY.COMMAND.RELOAD_FAILURE)
+                    .replace("%nl%", "\n")));
+      }
+
+      elytraProxy.reload(source);
+    }
+
+    @Override
+    public boolean hasPermission(final CommandSource source, final String @NonNull [] args) {
+      return source.hasPermission("elytraproxy.command.reload");
+    }
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java
new file mode 100644
index 00000000..69861ff3
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Config.java
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2021 Elytrium
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config;
+
+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.AtomicMoveNotSupportedException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.nio.file.StandardOpenOption;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import ru.elytrium.elytraproxy.config.helpers.Configuration;
+import ru.elytrium.elytraproxy.config.helpers.ConfigurationProvider;
+import ru.elytrium.elytraproxy.config.helpers.YamlConfiguration;
+
+@SuppressFBWarnings("RV_RETURN_VALUE_IGNORED")
+public class Config {
+  private final Logger logger = LogManager.getLogger("ElytraProxy");
+
+  public Config() {
+    save(new ArrayList<>(), getClass(), this, 0);
+  }
+
+  /**
+   * Set the value of a specific node<br>
+   * Probably throws some error if you supply non existing keys or invalid
+   * values
+   *
+   * @param key   config node
+   * @param value value
+   */
+  private void set(String key, Object value) {
+    String[] split = key.split("\\.");
+    Object instance = getInstance(split, this.getClass());
+    if (instance != null) {
+      Field field = getField(split, instance);
+      if (field != null) {
+        try {
+          if (field.getAnnotation(Final.class) != null) {
+            return;
+          }
+          if (field.getType() == String.class && !(value instanceof String)) {
+            value = value + "";
+          }
+          field.set(instance, value);
+          return;
+        } catch (IllegalAccessException | IllegalArgumentException e) {
+          logger.warn("Error:", e);
+        }
+      }
+    }
+    logger.warn("Failed to set config option: {}: {} | {} ", new Object[] {
+        key, value, instance
+    });
+  }
+
+  public void set(Configuration yml, String oldPath) {
+    for (String key : yml.getKeys()) {
+      Object value = yml.get(key);
+      String newPath = oldPath + (oldPath.isEmpty() ? "" : ".") + key;
+      if (value instanceof Configuration) {
+        set((Configuration) value, newPath);
+        continue;
+      }
+      set(newPath, value);
+    }
+  }
+
+  public boolean load(File file) {
+    if (!file.exists()) {
+      /* TODO: дописать там крч типа ага да
+      logger.error("****************************************");
+      logger.warn("тут короче ссылка на плагины остальные будет,"
+              + "типа зацени наши другие плагины ёпт.");
+      logger.error("****************************************");
+      */
+      return false;
+    }
+    Configuration yml;
+    try {
+      try (InputStreamReader reader = new InputStreamReader(
+              new FileInputStream(file), StandardCharsets.UTF_8)) {
+        yml = ConfigurationProvider.getProvider(YamlConfiguration.class).load(reader);
+      }
+    } catch (IOException ex) {
+      logger.warn("Unable to load config ", ex);
+      return false;
+    }
+    set(yml, "");
+    return true;
+  }
+
+  /**
+   * Set all values in the file (load first to avoid overwriting)
+   *
+   * @param file file
+   */
+  public void save(File file) {
+    try {
+      File parent = file.getParentFile();
+      if (parent != null) {
+        file.getParentFile().mkdirs();
+      }
+      Path configFile = file.toPath();
+      Path tempCfg = new File(file.getParentFile(), "__tmpcfg").toPath();
+      List<String> lines = new ArrayList<>();
+      save(lines, getClass(), this, 0);
+
+      Files.write(tempCfg, lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE);
+      try {
+        Files.move(
+            tempCfg, configFile,
+            StandardCopyOption.REPLACE_EXISTING,
+            StandardCopyOption.ATOMIC_MOVE);
+      } catch (AtomicMoveNotSupportedException e) {
+        Files.move(tempCfg, configFile, StandardCopyOption.REPLACE_EXISTING);
+      }
+    } catch (IOException e) {
+      logger.warn("Error:", e);
+    }
+  }
+
+  private void save(List<String> lines, Class clazz, final Object instance, int indent) {
+    try {
+      String spacing = repeat(" ", indent);
+      for (Field field : clazz.getFields()) {
+        if (field.getAnnotation(Ignore.class) != null) {
+          continue;
+        }
+        Class<?> current = field.getType();
+        if (field.getAnnotation(Ignore.class) != null) {
+          continue;
+        }
+        Comment comment = field.getAnnotation(Comment.class);
+        if (comment != null) {
+          for (String commentLine : comment.value()) {
+            lines.add(spacing + "# " + commentLine);
+          }
+        }
+        Create create = field.getAnnotation(Create.class);
+        if (create != null) {
+          Object value = field.get(instance);
+          setAccessible(field);
+          if (indent == 0) {
+            lines.add("");
+          }
+          comment = current.getAnnotation(Comment.class);
+          if (comment != null) {
+            for (String commentLine : comment.value()) {
+              lines.add(spacing + "# " + commentLine);
+            }
+          }
+          lines.add(spacing + toNodeName(current.getSimpleName()) + ":");
+          if (value == null) {
+            field.set(instance, value = current.newInstance());
+          }
+          save(lines, current, value, indent + 2);
+        } else {
+          lines.add(spacing + toNodeName(field.getName() + ": ")
+                  + toYamlString(field.get(instance), spacing));
+        }
+      }
+    } catch (RuntimeException e) {
+      logger.warn("RuntimeEx Error:", e);
+    } catch (Exception e) {
+      logger.warn("Error:", e);
+    }
+  }
+
+  /**
+   * Indicates that a field should be instantiated / created
+   */
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({ElementType.FIELD})
+  public @interface Create {
+  }
+
+  /**
+   * Indicates that a field cannot be modified
+   */
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target(ElementType.FIELD)
+  public @interface Final {
+  }
+
+  /**
+   * Creates a comment
+   */
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({ElementType.FIELD, ElementType.TYPE})
+  public @interface Comment {
+
+      String[] value();
+  }
+
+  /**
+   * Any field or class with is not part of the config
+   */
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target({ElementType.FIELD, ElementType.TYPE})
+  public @interface Ignore {
+  }
+
+  private String toYamlString(Object value, String spacing) {
+    if (value instanceof List) {
+      Collection<?> listValue = (Collection<?>) value;
+      if (listValue.isEmpty()) {
+        return "[]";
+      }
+      StringBuilder m = new StringBuilder();
+      for (Object obj : listValue) {
+        m.append(
+          System.lineSeparator()).append(spacing).append("- ").append(toYamlString(obj, spacing));
+      }
+      return m.toString();
+    }
+    if (value instanceof String) {
+      String stringValue = (String) value;
+      if (stringValue.isEmpty()) {
+        return "''";
+      }
+      return "\"" + stringValue + "\"";
+    }
+    return value != null ? value.toString() : "null";
+  }
+
+  /**
+   * Get the field for a specific config node and instance<br>
+   * Note: As expiry can have multiple blocks there will be multiple instances
+   *
+   * @param split    the node (split by period)
+   * @param instance the instance
+   * @return Field field
+   */
+  private Field getField(String[] split, Object instance) {
+    try {
+      Field field = instance.getClass().getField(toFieldName(split[split.length - 1]));
+      setAccessible(field);
+      return field;
+    } catch (IllegalAccessException
+            | NoSuchFieldException
+            | SecurityException
+            | NoSuchMethodException
+            | InvocationTargetException e) {
+      logger.warn("Invalid config field: {} for {}", new Object[]
+      {
+          String.join(".", split), toNodeName(instance.getClass().getSimpleName())
+      });
+      return null;
+    }
+  }
+
+  /**
+   * Get the instance for a specific config node
+   *
+   * @param split the node (split by period)
+   * @param root  the root class
+   * @return The instance or null
+   */
+  private Object getInstance(String[] split, Class root) {
+    try {
+      Class<?> clazz = root == null ? MethodHandles.lookup().lookupClass() : root;
+      Object instance = this;
+      while (split.length > 0) {
+        switch (split.length) {
+          case 1:
+            return instance;
+          default:
+            Class found = null;
+            Class<?>[] classes = clazz.getDeclaredClasses();
+            for (Class current : classes) {
+              if (current.getSimpleName().equalsIgnoreCase(toFieldName(split[0]))) {
+                found = current;
+                break;
+              }
+            }
+            try {
+              Field instanceField = clazz.getDeclaredField(toFieldName(split[0]));
+              setAccessible(instanceField);
+              Object value = instanceField.get(instance);
+              if (value == null) {
+                value = found.newInstance();
+                instanceField.set(instance, value);
+              }
+              clazz = found;
+              instance = value;
+              split = Arrays.copyOfRange(split, 1, split.length);
+              continue;
+            } catch (NoSuchFieldException
+                    | NoSuchMethodException
+                    | InvocationTargetException ignore) {
+              //
+            }
+            return null;
+        }
+      }
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+    return null;
+  }
+
+  /**
+   * Translate a node to a java field name
+   *
+   * @param node node to translate
+   * @return java field name
+   */
+  private String toFieldName(String node) {
+    return node.toUpperCase().replaceAll("-", "_");
+  }
+
+  /**
+   * Translate a field to a config node
+   *
+   * @param field to translate
+   * @return config node name
+   */
+  private String toNodeName(String field) {
+    return field.toLowerCase().replace("_", "-");
+  }
+
+  /**
+   * Set some field to be accesible
+   *
+   * @param field to be accesible
+   * @throws NoSuchFieldException   ...
+   * @throws IllegalAccessException ...
+   */
+  private void setAccessible(Field field) throws NoSuchFieldException,
+          IllegalAccessException, NoSuchMethodException, InvocationTargetException {
+    field.setAccessible(true);
+    int modifiers = field.getModifiers();
+    if (Modifier.isFinal(modifiers)) {
+      try {
+        Field modifiersField = Field.class.getDeclaredField("modifiers");
+        modifiersField.setAccessible(true);
+        modifiersField.setInt(field, modifiers & ~Modifier.FINAL);
+      } catch (NoSuchFieldException e) {
+        // Java 12 compatibility *this is fine*
+        Method getDeclaredFields0 = Class.class.getDeclaredMethod(
+                "getDeclaredFields0", boolean.class);
+        getDeclaredFields0.setAccessible(true);
+        Field[] fields = (Field[]) getDeclaredFields0.invoke(Field.class, false);
+        for (Field classField : fields) {
+          if ("modifiers".equals(classField.getName())) {
+            classField.setAccessible(true);
+            classField.set(field, modifiers & ~Modifier.FINAL);
+            break;
+          }
+        }
+      }
+    }
+  }
+
+  private String repeat(final String s, final int n) {
+    final StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < n; i++) {
+      sb.append(s);
+    }
+    return sb.toString();
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java
new file mode 100644
index 00000000..5115678e
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/Settings.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2021 Elytrium
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package ru.elytrium.elytraproxy.config;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+public class Settings extends Config {
+
+  @Ignore
+  public static final Settings IMP = new Settings();
+
+  @Final
+  public String VERSION = "0.1.1";
+
+  @Create
+  public MESSAGES MESSAGES;
+
+  @Comment("Don't use \\n, use %nl% for new line. Ampersand (&) color codes are supported too.")
+  public static class MESSAGES {
+    @Create
+    public MESSAGES.ELYTRAPROXY ELYTRAPROXY;
+    @Create
+    public MESSAGES.VELOCITY VELOCITY;
+
+    @Comment("alert-prefix, command-spy-format, log-command-executions-format, protocol-blocked, glist-format-view-all and nick-blocked doesn't have prefix.")
+    public static class ELYTRAPROXY {
+      public String PREFIX = "&5&l[ElytraProxy]&f ";
+      public String ALERT_PREFIX = "&8[&4Alert&8]&f ";
+      public String IF_CONSOLE = "CONSOLE";
+      public String ALERT_MESSAGE_NEEDED = "You must supply a message.";
+      public String ALERT_SERVER_EMPTY = "Server is empty.";
+      public String FIND_USERNAME_NEEDED = "Please follow this command by a user name.";
+      public String FIND_USER_ONLINE_AT = "&6{0} &fis online at &6{1}";
+      public String USER_NOT_ONLINE = "&6{0} &fis not online.";
+      public String SEND_YOU_GOT_SUMMONED = "Summoned to &6{0} &fby &6{1}";
+      public String SEND_NOT_ENOUGH_ARGUMENTS = "Not enough arguments, usage: &6/send <server|player|all|current> <target>";
+      public String COMMAND_SPY_FORMAT = "&7 — Player {0} executed command {1}";
+      public String CONSOLE_LOG_COMMAND_EXECUTIONS_FORMAT = "{0} -> executed command {1}";
+      public String PROTOCOL_BLOCKED = "&c1.7.x not supported";
+      public String NICK_BLOCKED = "&cYour nickname contains forbidden phrases.";
+      public String RELOAD_SUCCESS = "ElytraProxy configuration successfully reloaded.";
+      public String RELOAD_FAILURE = "&cUnable to reload your ElytraProxy configuration. Check the console for more details.";
+      /*
+      public String MYSQL_LOAD_FAILED: "Ошибка при инициализации базы данных. Выключение..."
+      */
+    }
+
+    @Comment({
+            "You may found other languages translations here: ",
+            "https://github.com/VelocityPowered/Velocity/tree/dev/2.0.0/proxy/src/main/resources/com/velocitypowered/proxy/l10n"
+    })
+    public static class VELOCITY {
+      @Create
+      public MESSAGES.VELOCITY.ERROR ERROR;
+      @Create
+      public MESSAGES.VELOCITY.COMMAND COMMAND;
+
+      @Comment("Error messages doesn't have ElytraProxy prefix")
+      public static class ERROR {
+        public String ALREADY_CONNECTED = "&cYou are already connected to this server!";
+        public String ALREADY_CONNECTED_PROXY = "&cYou are already connected to this proxy!";
+        public String ALREADY_CONNECTING = "&cYou are already trying to connect to a server!";
+        public String CANT_CONNECT = "&cUnable to connect to &6{0}&c: &6{1}";
+        public String CONNECTING_SERVER_ERROR = "&cUnable to connect you to &6{0}&c. Please try again later.";
+        public String CONNECTED_SERVER_ERROR = "&cYour connection to &6{0} &cencountered a problem.";
+        public String INTERNAL_SERVER_CONNECTION_ERROR = "&cAn internal server connection error occurred.";
+        // public String LOGGING_IN_TOO_FAST = "&cYou are logging in too fast, try again later.";
+        public String ONLINE_MODE_ONLY = "&cYou are not logged into your Minecraft account. If you are logged into your Minecraft account, try restarting your Minecraft client.";
+        public String PLAYER_CONNECTION_ERROR = "&cAn internal error occurred in your connection.";
+        public String MODERN_FORWARDING_NEEDS_NEW_CLIENT = "&cThis server is only compatible with Minecraft 1.13 and above.";
+        public String MODERN_FORWARDING_FAILED = "&cYour server did not send a forwarding request to the proxy. Make sure the server is configured for Velocity forwarding.";
+        public String MOVED_TO_NEW_SERVER = "&cYou were kicked from &6{0}&c: &6{1}";
+        public String NO_AVAILABLE_SERVERS = "&cThere are no available servers to connect you to. Try again later or contact an admin.";
+      }
+
+      public static class COMMAND {
+        public String GENERIC_ERROR = "An error occurred while running this command.";
+        public String COMMAND_DOES_NOT_EXIST = "This command does not exist.";
+        public String PLAYERS_ONLY = "Only players can run this command.";
+        public String SERVER_DOES_NOT_EXIST = "The specified server &6{0} &fdoes not exist.";
+        public String SERVER_CURRENT_SERVER = "You are currently connected to &6{0}.";
+        public String SERVER_TOO_MANY = "There are too many servers set up. Use tab completion to view all servers available.";
+        public String SERVER_AVAILABLE = "Available servers: &6";
+        public String SERVER_TOOLTIP_CURRENT_SERVER = "Currently connected to this server%nl%&6{0}";
+        public String SERVER_TOOLTIP_PLAYER_ONLINE = "&6{0} &fplayer online";
+        public String SERVER_TOOLTIP_PLAYERS_ONLINE = "&6{0} &fplayers online";
+        public String SERVER_TOOLTIP_OFFER_CONNECT_SERVER = "Click to connect to this server%nl%&6{0}";
+        public String GLIST_VIEW_ALL = "To view all players on servers, use &6/glist all&f.";
+        public String GLIST_PLAYER_SINGULAR = "&6{0} &fplayer is currently connected to the proxy.";
+        public String GLIST_PLAYER_PLURAL = "&6{0} &fplayers are currently connected to the proxy.";
+        public String GLIST_FORMAT_VIEW_ALL = "&f[&6{0}&f] (&6{1}&f): ";
+        public String RELOAD_SUCCESS = "Velocity configuration successfully reloaded.";
+        public String RELOAD_FAILURE = "&cUnable to reload your Velocity configuration. Check the console for more details.";
+      }
+    }
+  }
+
+  @Create
+  public MAIN_SETTINGS MAIN_SETTINGS;
+
+  public static class MAIN_SETTINGS {
+    @Comment("How many attempts are allowed before rate limiting?")
+    public int LOGIN_RATELIMIT_ATTEMPTS = 4;
+    @Comment({
+            "The list of protocols can be found here https://wiki.vg/Protocol_version_numbers",
+            "For example, the list contains all protocols of version 1.7.x",
+            "That is, with version 1.7 will not be able to connect"
+    })
+    public List<Integer> BANNED_PROTOCOLS = Arrays.asList(5, 4, 3, 2, 1, 0);
+    @Comment({
+            "Changes server brand in F3",
+            "Placeholders:",
+            "{ServerBrand} - returns the server on which the player is located",
+            "{ProxyBrand} - returns the proxy original brand"
+    })
+    public String BRAND = "{ServerBrand} => {ProxyBrand} (by ElytraDev)";
+    @Comment("Changes server version in ping request")
+    public String PING_VERSION = "ElytraProxy (by ElytraDev)";
+    @Comment("Enables command spy for players with permission elytraproxy.commandspy")
+    public boolean ENABLE_COMMAND_SPY_IN_CHAT = true;
+
+    @Create
+    public MAIN_SETTINGS.HOSTNAMES_MANAGER HOSTNAMES_MANAGER;
+
+    @Comment({
+            "Allows you to reject connection to the server for all domains except yours and direct ip",
+            "Most likely does not work with SRV records"
+    })
+    public static class HOSTNAMES_MANAGER {
+      public boolean ENABLE = false;
+      @Comment("If whitelist enabled, all hostnames (domains and ips) in list WON'T BE BLOCKED, but other hostnames WILL BE BLOCKED")
+      public boolean WHITELIST = true;
+      public boolean DOMAINS_CHECK = false;
+      public boolean IPS_CHECK = true;
+      public List<String> HOSTNAMES = Arrays.asList("your-digital-ip", "your-domain.com");
+      @Comment("IP's in this list will be ignored in check.")
+      public List<String> IGNORED_IPS = Arrays.asList("127.0.0.1", "your-haproxy-ip");
+    }
+  }
+
+  @Create
+  public ANTIBOT ANTIBOT;
+
+  public static class ANTIBOT {
+    public boolean ENABLE = true;
+    @Comment({
+            "If the player's nickname contains something from this list, hes connection will be rejected",
+            "In lowercase"
+    })
+    public List<String> BANNED_NICK_PATTERNS = Arrays.asList(
+          "dropbot", "mcspam", "mcdrop", "mcrage", "mcstorm", "extremebot", "cipher_bot", "biboran"
+    );
+  }
+
+  /*
+  @Create
+  public AUTH AUTH;
+
+  public static class AUTH {
+    public boolean ENABLE = true;
+    public boolean ONLINE_MODE_REQUIRES_LOGIN = false;
+    public String TABLE = "auth";
+  }
+
+  @Create
+  public DATABASE DATABASE;
+
+  @Comment("Database settings")
+  public static class DATABASE {
+    //@Comment("Тип датабазы. mysql или mysql))")
+    //public String STORAGE_TYPE = "mysql";
+    @Comment("Settings for MYSQL")
+    public String HOSTNAME = "127.0.0.1";
+    public int PORT = 3306;
+    public String USER = "user";
+    public String PASSWORD = "password";
+    public String DATABASE = "elytraproxy";
+  }
+  */
+
+  public void reload(File file) {
+    load(file);
+    save(file);
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java
new file mode 100644
index 00000000..1aaffedf
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/Configuration.java
@@ -0,0 +1,377 @@
+/*
+ * This file is part of BungeeCord, licensed under the BSD License (BSD).
+ *
+ * Copyright (c) 2012 md_5
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice,
+ *       this list of conditions and the following disclaimer in the documentation
+ *       and/or other materials provided with the distribution.
+ *     * The name of the author may not be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *     * You may not use the software for commercial software hosting services without
+ *       written permission from the author.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+
+public final class Configuration {
+
+  private static final char SEPARATOR = '.';
+  final Map<String, Object> self;
+  private final Configuration defaults;
+
+  public Configuration() {
+    this(null);
+  }
+
+  public Configuration(Configuration defaults) {
+    this(new LinkedHashMap<String, Object>(), defaults);
+  }
+
+  Configuration(Map<?, ?> map, Configuration defaults) {
+    this.self = new LinkedHashMap<>();
+    this.defaults = defaults;
+
+    for (Map.Entry<?, ?> entry : map.entrySet()) {
+      String key = (entry.getKey() == null) ? "null" : entry.getKey().toString();
+
+      if (entry.getValue() instanceof Map) {
+        this.self.put(key, new Configuration((Map) entry.getValue(),
+                (defaults == null) ? null : defaults.getSection(key)));
+      } else {
+        this.self.put(key, entry.getValue());
+      }
+    }
+  }
+
+  private Configuration getSectionFor(String path) {
+    int index = path.indexOf(SEPARATOR);
+    if (index == -1) {
+      return this;
+    }
+
+    String root = path.substring(0, index);
+    Object section = self.get(root);
+    if (section == null) {
+      section = new Configuration((defaults == null) ? null : defaults.getSection(root));
+      self.put(root, section);
+    }
+
+    return (Configuration) section;
+  }
+
+  private String getChild(String path) {
+    int index = path.indexOf(SEPARATOR);
+    return (index == -1) ? path : path.substring(index + 1);
+  }
+
+  /*------------------------------------------------------------------------*/
+  @SuppressWarnings("unchecked")
+  public <T> T get(String path, T def) {
+    Configuration section = getSectionFor(path);
+    Object val;
+    if (section == this) {
+      val = self.get(path);
+    } else {
+      val = section.get(getChild(path), def);
+    }
+
+    if (val == null && def instanceof Configuration) {
+      self.put(path, def);
+    }
+
+    return (val != null) ? (T) val : def;
+  }
+
+  public Object get(String path) {
+    return get(path, getDefault(path));
+  }
+
+  public boolean contains(String path) {
+    return get(path, null) != null;
+  }
+
+  public Object getDefault(String path) {
+    return (defaults == null) ? null : defaults.get(path);
+  }
+
+  public void set(String path, Object value) {
+    if (value instanceof Map) {
+      value = new Configuration((Map) value,
+              (defaults == null) ? null : defaults.getSection(path));
+    }
+
+    Configuration section = getSectionFor(path);
+    if (section == this) {
+      if (value == null) {
+        self.remove(path);
+      } else {
+        self.put(path, value);
+      }
+    } else {
+      section.set(getChild(path), value);
+    }
+  }
+
+  /*------------------------------------------------------------------------*/
+  public Configuration getSection(String path) {
+    Object def = getDefault(path);
+    return (Configuration) get(path,
+            (def instanceof Configuration) ? def : new Configuration((
+                    defaults == null) ? null : defaults.getSection(path)));
+  }
+
+  /**
+   * Gets keys, not deep by default.
+   *
+   * @return top level keys for this section
+   */
+  public Collection<String> getKeys() {
+    return new LinkedHashSet<>(self.keySet());
+  }
+
+  /*------------------------------------------------------------------------*/
+  public byte getByte(String path) {
+    Object def = getDefault(path);
+    return getByte(path, (def instanceof Number) ? ((Number) def).byteValue() : 0);
+  }
+
+  public byte getByte(String path, byte def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).byteValue() : def;
+  }
+
+  public List<Byte> getByteList(String path) {
+    List<?> list = getList(path);
+    List<Byte> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).byteValue());
+      }
+    }
+
+    return result;
+  }
+
+  public short getShort(String path) {
+    Object def = getDefault(path);
+    return getShort(path, (def instanceof Number) ? ((Number) def).shortValue() : 0);
+  }
+
+  public short getShort(String path, short def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).shortValue() : def;
+  }
+
+  public List<Short> getShortList(String path) {
+    List<?> list = getList(path);
+    List<Short> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).shortValue());
+      }
+    }
+
+    return result;
+  }
+
+  public int getInt(String path) {
+    Object def = getDefault(path);
+    return getInt(path, (def instanceof Number) ? ((Number) def).intValue() : 0);
+  }
+
+  public int getInt(String path, int def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).intValue() : def;
+  }
+
+  public List<Integer> getIntList(String path) {
+    List<?> list = getList(path);
+    List<Integer> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).intValue());
+      }
+    }
+
+    return result;
+  }
+
+  public long getLong(String path) {
+    Object def = getDefault(path);
+    return getLong(path, (def instanceof Number) ? ((Number) def).longValue() : 0);
+  }
+
+  public long getLong(String path, long def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).longValue() : def;
+  }
+
+  public List<Long> getLongList(String path) {
+    List<?> list = getList(path);
+    List<Long> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).longValue());
+      }
+    }
+
+    return result;
+  }
+
+  public float getFloat(String path) {
+    Object def = getDefault(path);
+    return getFloat(path, (def instanceof Number) ? ((Number) def).floatValue() : 0);
+  }
+
+  public float getFloat(String path, float def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).floatValue() : def;
+  }
+
+  public List<Float> getFloatList(String path) {
+    List<?> list = getList(path);
+    List<Float> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).floatValue());
+      }
+    }
+
+    return result;
+  }
+
+  public double getDouble(String path) {
+    Object def = getDefault(path);
+    return getDouble(path, (def instanceof Number) ? ((Number) def).doubleValue() : 0);
+  }
+
+  public double getDouble(String path, double def) {
+    Object val = get(path, def);
+    return (val instanceof Number) ? ((Number) val).doubleValue() : def;
+  }
+
+  public List<Double> getDoubleList(String path) {
+    List<?> list = getList(path);
+    List<Double> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Number) {
+        result.add(((Number) object).doubleValue());
+      }
+    }
+
+    return result;
+  }
+
+  public boolean getBoolean(String path) {
+    Object def = getDefault(path);
+    return getBoolean(path, (def instanceof Boolean) ? (Boolean) def : false);
+  }
+
+  public boolean getBoolean(String path, boolean def) {
+    Object val = get(path, def);
+    return (val instanceof Boolean) ? (Boolean) val : def;
+  }
+
+  public List<Boolean> getBooleanList(String path) {
+    List<?> list = getList(path);
+    List<Boolean> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Boolean) {
+        result.add((Boolean) object);
+      }
+    }
+
+    return result;
+  }
+
+  public char getChar(String path) {
+    Object def = getDefault(path);
+    return getChar(path, (def instanceof Character) ? (Character) def : '\u0000');
+  }
+
+  public char getChar(String path, char def) {
+    Object val = get(path, def);
+    return (val instanceof Character) ? (Character) val : def;
+  }
+
+  public List<Character> getCharList(String path) {
+    List<?> list = getList(path);
+    List<Character> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof Character) {
+        result.add((Character) object);
+      }
+    }
+    return result;
+  }
+
+  public String getString(String path) {
+    Object def = getDefault(path);
+    return getString(path, (def instanceof String) ? (String) def : "");
+  }
+
+  public String getString(String path, String def) {
+    Object val = get(path, def);
+    return (val instanceof String) ? (String) val : def;
+  }
+
+  public List<String> getStringList(String path) {
+    List<?> list = getList(path);
+    List<String> result = new ArrayList<>();
+
+    for (Object object : list) {
+      if (object instanceof String) {
+        result.add((String) object);
+      }
+    }
+
+    return result;
+  }
+
+  /*------------------------------------------------------------------------*/
+  public List<?> getList(String path) {
+    Object def = getDefault(path);
+    return getList(path, (def instanceof List<?>) ? (List<?>) def : Collections.EMPTY_LIST);
+  }
+
+  public List<?> getList(String path, List<?> def) {
+    Object val = get(path, def);
+    return (val instanceof List<?>) ? (List<?>) val : def;
+  }
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java
new file mode 100644
index 00000000..5f4dc5f7
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/ConfigurationProvider.java
@@ -0,0 +1,81 @@
+/*
+ * This file is part of BungeeCord, licensed under the BSD License (BSD).
+ *
+ * Copyright (c) 2012 md_5
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice,
+ *       this list of conditions and the following disclaimer in the documentation
+ *       and/or other materials provided with the distribution.
+ *     * The name of the author may not be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *     * You may not use the software for commercial software hosting services without
+ *       written permission from the author.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.HashMap;
+import java.util.Map;
+
+public abstract class ConfigurationProvider {
+
+  private static final Map<Class<? extends ConfigurationProvider>,
+          ConfigurationProvider> providers = new HashMap<>();
+
+  static {
+    try {
+      providers.put(YamlConfiguration.class, new YamlConfiguration());
+    } catch (NoClassDefFoundError ex) {
+      // Ignore, no SnakeYAML
+    }
+  }
+
+  public static ConfigurationProvider getProvider(Class<? extends ConfigurationProvider> provider) {
+    return providers.get(provider);
+  }
+
+  /*------------------------------------------------------------------------*/
+  public abstract void save(Configuration config, File file) throws IOException;
+
+  public abstract void save(Configuration config, Writer writer);
+
+  public abstract Configuration load(File file) throws IOException;
+
+  public abstract Configuration load(File file, Configuration defaults) throws IOException;
+
+  public abstract Configuration load(Reader reader);
+
+  public abstract Configuration load(Reader reader, Configuration defaults);
+
+  public abstract Configuration load(InputStream is);
+
+  public abstract Configuration load(InputStream is, Configuration defaults);
+
+  public abstract Configuration load(String string);
+
+  public abstract Configuration load(String string, Configuration defaults);
+}
diff --git a/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java
new file mode 100644
index 00000000..34fa8a99
--- /dev/null
+++ b/proxy/src/main/java/ru/elytrium/elytraproxy/config/helpers/YamlConfiguration.java
@@ -0,0 +1,150 @@
+/*
+ * This file is part of BungeeCord, licensed under the BSD License (BSD).
+ *
+ * Copyright (c) 2012 md_5
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *     * Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright notice,
+ *       this list of conditions and the following disclaimer in the documentation
+ *       and/or other materials provided with the distribution.
+ *     * The name of the author may not be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *     * You may not use the software for commercial software hosting services without
+ *       written permission from the author.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package ru.elytrium.elytraproxy.config.helpers;
+
+import com.google.common.base.Charsets;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStreamWriter;
+import java.io.Reader;
+import java.io.Writer;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import lombok.AccessLevel;
+import lombok.NoArgsConstructor;
+import org.yaml.snakeyaml.DumperOptions;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.constructor.Constructor;
+import org.yaml.snakeyaml.nodes.Node;
+import org.yaml.snakeyaml.representer.Represent;
+import org.yaml.snakeyaml.representer.Representer;
+
+@NoArgsConstructor(access = AccessLevel.PACKAGE)
+public class YamlConfiguration extends ConfigurationProvider {
+
+  private final ThreadLocal<Yaml> yaml = new ThreadLocal<Yaml>() {
+    @Override
+    protected Yaml initialValue() {
+      Representer representer = new Representer() {
+        {
+          representers.put(Configuration.class, new Represent() {
+            @Override
+            public Node representData(Object data) {
+              return represent(((Configuration) data).self);
+            }
+          });
+        }
+      };
+
+      DumperOptions options = new DumperOptions();
+      options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
+
+      return new Yaml(new Constructor(), representer, options);
+    }
+  };
+
+  @Override
+  public void save(Configuration config, File file) throws IOException {
+    try (Writer writer = new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8)) {
+      save(config, writer);
+    }
+  }
+
+  @Override
+  public void save(Configuration config, Writer writer) {
+    yaml.get().dump(config.self, writer);
+  }
+
+  @Override
+  public Configuration load(File file) throws IOException {
+    return load(file, null);
+  }
+
+  @Override
+  public Configuration load(File file, Configuration defaults) throws IOException {
+    try (FileInputStream is = new FileInputStream(file)) {
+      return load(is, defaults);
+    }
+  }
+
+  @Override
+  public Configuration load(Reader reader) {
+    return load(reader, null);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public Configuration load(Reader reader, Configuration defaults) {
+    Map<String, Object> map = yaml.get().loadAs(reader, LinkedHashMap.class);
+    if (map == null) {
+      map = new LinkedHashMap<>();
+    }
+    return new Configuration(map, defaults);
+  }
+
+  @Override
+  public Configuration load(InputStream is) {
+    return load(is, null);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public Configuration load(InputStream is, Configuration defaults) {
+    Map<String, Object> map = yaml.get().loadAs(is, LinkedHashMap.class);
+    if (map == null) {
+      map = new LinkedHashMap<>();
+    }
+    return new Configuration(map, defaults);
+  }
+
+  @Override
+  public Configuration load(String string) {
+    return load(string, null);
+  }
+
+  @Override
+  @SuppressWarnings("unchecked")
+  public Configuration load(String string, Configuration defaults) {
+    Map<String, Object> map = yaml.get().loadAs(string, LinkedHashMap.class);
+    if (map == null) {
+      map = new LinkedHashMap<>();
+    }
+    return new Configuration(map, defaults);
+  }
+}
-- 
2.24.1.windows.2

